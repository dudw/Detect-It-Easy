// Detect It Easy: DiE-JS framework file
// Don't change anything unless you're sure about what you're doing

// Author: Kae <TG@kaens>

/* A collection of binary (bytecodes, disassemblers) parsers intended for sanity checks.
Each parser must have these parameters (len optional):
    {UInt} [p=0] - pointer (file offset) from where to begin
    {Int} [len=BCParseUntilReasonable] - either the block length or one of the constants above. Not all parsers will support all constants (EoF is implied anyway, and there may not be end markers in a format) but the ToReasonable must be present.
It must return a list [n, e, 0, ...] where:
    - n: BCInvalidFormat, or the first value is the number of commands parsed,or the number of notes read. If n is BCInvalidFormat, the other return list values may be absent;
    - e: -1 or the position after the end marker;
    - 0: [reserved]
    - any custom useful data, such as tags, may be added as well (values [3...]).
*/
/* beautify ignore:start */

//Put these in the length parameter when you're unsure how long the tested block is
BCParseToReasonable = 0; // the default idea of the parser
BCParseToEoF = -1; // physical file end
BCParseToEndMarker = -2; // logical block end (like an end-block bytecode, RET in disassembly...)
BCInvalidFormat = -1;

const debug = 0;

// -= Yamaha YM2151 FM Operator Type-M (OPM) related functionality =-

function isYM2151Reg(a) {
    //The OPM doesn't use these registers so we break off if we hit one:
    return (
        [
            0, 2, 3, 4, 5, 6, 7, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0x10, 0x13, 0x15, 0x16, 0x17, 0x1a, 0x1c, 0x1d, 0x1e, 0x1f
        ].indexOf(a) < 0
    );
}

function YM2151RegStr(a, b) {
    //from https://retrocdn.net/images/9/9c/YM2151_Application_Manual.pdf
    // & https://cx5m.file-hunter.com/fmunit.htm - this one contains errors!
    if (!isYM2151Reg(a)) return "!bad#" + Hex(a);
    if (a == 1)
        if ((b & 2) == b) return "LFOR";
        else return "TEST" + Bin(b);
    if (a == 8) return "keyon ch" + (b & 7) + " slot" + Bin((b >> 3) & 0xf);
    if (a == 0xf) return "noise" + ["off", "on"][b >> 7] + " freq" + Hex(b >> 0x1f);
    if (a == 0x11) return "CLKA MSB freq" + Hex(b);
    if (a == 0x12) return "CLKA LSB freq" + Hex(b & 3);
    if (a == 0x13) return "CLKB freq" + Hex(b);
    if (a == 0x14)
        return (
            "Clk CSM" +
            (b >> 7) +
            " FResetBA" +
            Bin((b >> 4) & 3, 2) +
            " IRQEnBA" +
            Bin((b >> 2) & 3, 2) +
            " LoadBA" +
            Bin(b & 3, 2)
        );
    if (a == 0x18) return "LowOscFreq " + Hex(b);
    if (a == 0x19) return ["Amp", "Phase"][b >> 7] + "Mod depth" + Hex(b & 0x7f);
    if (a == 0x1b) return "LFOWave ctl" + (b >> 6) + " " + ["saw", "sqr", "tri", "noise"][b & 3];
    if (a <= 0x27)
        return (
            "Ch " +
            (a & 0x7) +
            " ctl " +
            (b & 0x80 ? "R" : "") +
            (b & 0x40 ? "L" : "") +
            " FB" +
            ((b >> 3) & 7) +
            " con" +
            (b & 7)
        );
    if (a <= 0x2f) {
        o = (b >> 4) & 7;
        return (
            "KC/prep note-on ch" +
            (a & 0x7) +
            " " +
            (o ? ["C#", "D", "D#", "", "E", "F", "F#", "", "G", "G#", "A", "", "A#", "B", "C", ""][b & 0xf] + o : "--")
        );
    }
    if (a <= 0x37) return "KF/prep p.bend ch" + (a & 0x7) + " kf" + (b >> 2);
    if (a <= 0x3f) return "ModSensy. ch" + (a & 0x7) + " phase" + ((b >> 4) & 7) + " amp" + (b & 3);
    if (a <= 0x47) return "OP1 ch" + (a & 0x7) + " dt1:" + ((b >> 4) & 7) + " mul" + (b & 0xf);
    if (a <= 0x4f) return "OP3 ch" + (a & 0x7) + " dt1:" + ((b >> 4) & 7) + " mul" + (b & 0xf);
    if (a <= 0x57) return "OP2 ch" + (a & 0x7) + " dt1:" + ((b >> 4) & 7) + " mul" + (b & 0xf);
    if (a <= 0x5f) return "OP4 ch" + (a & 0x7) + " dt1:" + ((b >> 4) & 7) + " mul" + (b & 0xf);
    if (a <= 0x67) return "OP1 ch" + (a & 0x7) + " TL" + (b & 0x7f);
    if (a <= 0x6f) return "OP3 ch" + (a & 0x7) + " TL" + (b & 0x7f);
    if (a <= 0x77) return "OP2 ch" + (a & 0x7) + " TL" + (b & 0x7f);
    if (a <= 0x7f) return "OP4 ch" + (a & 0x7) + " TL" + (b & 0x7f);
    if (a <= 0x87) return "OP1 ch" + (a & 0x7) + " KeyScl" + (b >> 6) + " atk" + (b & 0x1f);
    if (a <= 0x8f) return "OP3 ch" + (a & 0x7) + " KeyScl" + (b >> 6) + " atk" + (b & 0x1f);
    if (a <= 0x97) return "OP2 ch" + (a & 0x7) + " KeyScl" + (b >> 6) + " atk" + (b & 0x1f);
    if (a <= 0x9f) return "OP4 ch" + (a & 0x7) + " KeyScl" + (b >> 6) + " atk" + (b & 0x1f);
    if (a <= 0xa7) return "OP1 ch" + (a & 0x7) + " AMS" + ["off", "on"][b >> 7] + " dcy1R:" + (b & 0x1f);
    if (a <= 0xaf) return "OP3 ch" + (a & 0x7) + " AMS" + ["off", "on"][b >> 7] + " dcy1R:" + (b & 0x1f);
    if (a <= 0xb7) return "OP2 ch" + (a & 0x7) + " AMS" + ["off", "on"][b >> 7] + " dcy1R:" + (b & 0x1f);
    if (a <= 0xbf) return "OP4 ch" + (a & 0x7) + " AMS" + ["off", "on"][b >> 7] + " dcy1R:" + (b & 0x1f);
    if (a <= 0xc7) return "OP1 ch" + (a & 0x7) + " dt2:" + (b >> 6) + " dcy2R:" + (b & 0x1f);
    if (a <= 0xcf) return "OP3 ch" + (a & 0x7) + " dt2:" + (b >> 6) + " dcy2R:" + (b & 0x1f);
    if (a <= 0xd7) return "OP2 ch" + (a & 0x7) + " dt2:" + (b >> 6) + " dcy2R:" + (b & 0x1f);
    if (a <= 0xdf) return "OP4 ch" + (a & 0x7) + " dt2:" + (b >> 6) + " dcy2R:" + (b & 0x1f);
    if (a <= 0xe7) return "OP1 ch" + (a & 0x7) + " dcy2L:" + (b >> 4) + " rel:" + (b & 0xf);
    if (a <= 0xef) return "OP3 ch" + (a & 0x7) + " dcy2L:" + (b >> 4) + " rel:" + (b & 0xf);
    if (a <= 0xf7) return "OP2 ch" + (a & 0x7) + " dcy2L:" + (b >> 4) + " rel:" + (b & 0xf);
    return "OP4 ch" + (a & 0x7) + " dcy2L:" + (b >> 4) + " rel:" + (b & 0xf);
}

// -= MDX/MXDRV command explainer, useful for loggers

function MDXCmdStr(ch, o) {
    const C = ["A", "B", "C", "D", "E", "F", "G", "H", "P", "Q", "R", "S", "T", "U", "V", "W"];
    const notes = ["D#", "E", "F", "F#", "G", "G#", "A", "A#", "B", "B#", "C", "C#", "D"];
    var c = X.U8(o);
    if (c < 0x80) return C[ch] + ": rest " + (c + 1);
    else if (c <= 0xdf) {
        c -= 0x80;
        if (ch > 8) return C[ch] + ": smp#" + c;
        else return C[ch] + ": " + notes[c % 12] + Util.divu64(c, 12) + " ~" + (X.U8(o + 1) + 1);
    } else
        switch (c) {
            case 0xff:
                return C[ch] + ": bpm " + X.U8(o + 1);
            case 0xfe:
                return C[ch] + ": R " + YM2151RegStr(X.U8(o + 1), X.U8(o + 2));
            case 0xfd:
                return C[ch] + ": voicedata " + X.U8(o + 1);
            case 0xfc:
                return C[ch] + ": pan " + X.U8(o + 1);
            case 0xfb:
                if (X.U8(o + 1) & 0x80) return C[ch] + ": @vol " + (X.U8(o + 1) & 0x7f);
                else return C[ch] + ": vol " + X.U8(o + 1);
            case 0xfa:
                return C[ch] + ": vol-";
            case 0xf9:
                return C[ch] + ": vol+";
            case 0xf8:
                return C[ch] + ": staccato " + X.U8(o + 1);
            case 0xf7:
                return C[ch] + ": legato";
            case 0xf6:
                return C[ch] + ": rep." + X.U8(o + 1) + " [" + (X.U8(o + 2) ? "/" + X.U8(o + 2) : "") + "...";
            case 0xf5:
                return C[ch] + ": ...]rep.,ret→" + Hex(o + X.I16(o + 1, _BE));
            case 0xf4:
                return C[ch] + ": .../rep.esc→" + Hex(o + X.I16(o + 1, _BE));
            case 0xf3:
                return C[ch] + ": detune " + X.I16(o + 1, _BE) / 0x40;
            case 0xf2:
                return C[ch] + ": portamento " + X.I16(o + 1, _BE) / 0x4000 + " ↓";
            case 0xf1:
                if (X.U8(o + 1)) return C[ch] + ": loop from " + Hex(o + 3 + X.I16(o + 1, _BE)) + ".";
                else return C[ch] + " ends.";
            case 0xf0:
                return C[ch] + ": delay key-on " + X.U8(o + 1);
            case 0xef:
                return C[ch] + ": sync send on ch" + X.U8(o + 1);
            case 0xee:
                return C[ch] + ": sync wait on ch" + X.U8(o + 1);
            case 0xed:
                return C[ch] + ": noise/smp freq " + X.U8(o + 1);
            case 0xec:
                if (X.U8(o + 1) == 0x80) return C[ch] + ": pitch LFO off";
                else if (X.U8(o + 1) == 0x81) return C[ch] + ": pitch LFO on";
                else
                    return (
                        C[ch] +
                        ": LFO pitch wf " +
                        X.U8(o + 1) +
                        " freq " +
                        X.U16(o + 2, _BE) +
                        " amp " +
                        X.U16(o + 4, _BE)
                    );
            case 0xeb:
                if (X.U8(o + 1) == 0x80) return C[ch] + ": vol LFO off";
                else if (X.U8(o + 1) == 0x81) return C[ch] + ": vol LFO on";
                else
                    return (
                        C[ch] +
                        ": LFO vol wf " +
                        X.U8(o + 1) +
                        " freq " +
                        X.U16(o + 2, _BE) +
                        " amp " +
                        X.U16(o + 4, _BE)
                    );
            case 0xea:
                if (X.U8(o + 1) == 0x80) return C[ch] + ": OPM LFO off";
                else if (X.U8(o + 1) == 0x81) return C[ch] + ": OPM LFO on";
                else
                    return (
                        C[ch] +
                        ": LFO OPM syn/wf " +
                        X.U8(o + 1) +
                        " lfrq " +
                        X.U8(o + 2) +
                        " PMD " +
                        X.U8(o + 3) +
                        " AMD " +
                        X.U8(o + 4) +
                        " P/AMS " +
                        X.U8(o + 5)
                    );
            case 0xe9:
                return C[ch] + ": LFO key-on dly " + X.U8(o + 1);
            case 0xe8:
                return C[ch] + ": PCM8 on";
            case 0xe7:
                return C[ch] + ": Fadeout" + (X.U8(o + 1) == 1 ? "" : Hex(X.U8(o + 1))) + " spd " + X.U8(o + 2);
            default:
                return C[ch] + ": unknown command " + Hex(X.U8(o));
        }
}

/** OPM/YM2151 register log detector. If <= 0, consider invalid.
 * no custom data or end marker to be expected.
 */
function parseYM2151RegLog(p, len) {
    //ref https://retrocdn.net/images/9/9c/YM2151_Application_Manual.pdf
    len = len || BCParseToReasonable;
    p = p || 0;
    var max = len == BCParseToEoF ? X.Sz() : Math.min(X.Sz(), p + 0x2000),
        notes = 0,
        ic = 0,
        confirmed = false,
        v = [0, 0, 0, 0, 0],
        chinits = [],
        r,
        x;
    for (var i = 0; i < 8; chinits[i++] = 0);
    function re(p, t) {
        if (debug > 1) _l2r("opm", p, t);
        return [BCInvalidFormat, p, 0];
    }
    function iC() {
        if (debug > 0) _l2r("opm", p - 2, Hex(r) + " - " + Hex(x) + ": invalid value");
        ic++;
    }
    while (!X.U8(p) && p < 0x2000) p++; //skip zeroes if any
    if (!X.U8(p)) return [BCInvalidFormat, p, 0]; //sanity, heuristics, just reasonable they'd cut off the meaningless zeroes
    while (p < max && ic < 10) {
        r = X.U8(p++);
        if (!r) continue;
        x = X.U8(p++);
        if (!isYM2151Reg(r)) iC();
        if (debug > 1) _logIt(YM2151RegStr(r, x));
        /* The working YM2151 regs are:
    01: TEST    |    08: x111 1222: (SM)KON, CH №    |    0F: 1xx2 2222: NE, NFRQ
    10: CLKA1    |    11: xxxx xx11: CLKA2    |    12: CLKAB
    14: 1x22 3344: CSM, FLAG RESET B&A, IRQ-EN B&A, LOAD B&A
    18: LFRQ    |    19: PMD/AMD    |    1B: 11xx xx22: CT, W    |    20~27: 1122 23333: RL, FB, CONECT
    28~2F: x111 2222: KC { OCT, NOTE }    |    30~37: 1111 11xx: KF    |    38~3F: x111 xx22: PMS, AMS
    40~5F: x111 2222: DT1, MUL    |    60~7F: x111 1111: TL    |    80~9F: 11x2 2222: KS, AR
    A0~BF: 1xx2 2222: AMS-EN, D1R    |    C0~DF: 11x2 2222:  DT2, D2R    |    E0~FF: 1111 2222: D1L, RR
*/
        if (r <= 0x27) {
            if (r == 1) {
                if (x & 0xfd) break;
            } else if (r == 8) {
                if (x & 0x78) {
                    notes += bitCount((x >> 3) & 0xf);
                    v[0]++;
                } else if (x & 0x80) iC();
                // if(chinits[r & 7] > 5) chok[r & 7]++ - but adapt to bitCount!
            } else if (r == 0xf) {
                if (x & 0x60) iC();
            } else if (r == 0x11) {
                if (x > 3) iC();
            } else if (r == 0x14) {
                if (x & 0x40) iC();
            } else if (r == 0x1b) {
                if (x & 0x3c) iC();
            }
        } else if (r <= 0x2f) {
            if (x & 0x80 || [3, 7, 0xb, 0xf].indexOf(x & 0xf) >= 0) iC();
        } else if (r <= 0x37) {
        } //{ if (x & 3) iC(); } // should be a filter but some tunes want it that way
        else if (r <= 0x3f) {
            if (x & 0x8c) iC();
        } else if (r <= 0x7f) {
            if (x & 0x80) iC();
            v[1]++;
            chinits[r & 7]++;
        } // TL set
        else if (r <= 0x9f) {
            if (x & 0x20) iC();
            v[2]++;
            chinits[r & 7]++;
        } // KS/AR set
        else if (r <= 0xbf) {
            if (x & 0x60) iC();
            v[3]++;
            chinits[r & 7]++;
        } // AMS/D1R set
        else if (r <= 0xdf) {
            if (x & 0x20) iC();
            v[4]++;
            chinits[r & 7]++;
        } // DT2/D2R set
        else {
            v[4]++;
            chinits[r & 7]++;
        } // D1L/RR set

        if (!confirmed)
            if (p > 0x1000)
                if (notes < 20 || v[0] < 24 || v[1] < 24 || v[2] < 24 || v[3] < 24 || v[4] < 24)
                    return [BCInvalidFormat]; // false positives can be pretty long!
                else confirmed = true;
    }
    var chok = 0;
    for (var i = 0; i < 8; i++) if (chinits[i] > 5) chok++;
    if (debug > 0) _logIt(outArray([notes, v, chok, p], 16));
    if (ic >= 40 || chok < 5 || notes < 20 || v[0] < 24 || v[1] < 24 || v[2] < 24 || v[3] < 24 || v[4] < 24)
        return [BCInvalidFormat, p, chok];
    return [notes, p, chok];
}

// -= Yamaha YM2612(OPN2) related functionality =-

function isYM2612Reg(a) {
    //The OPN2 doesn't these registers:
    return !(
        a < 0x22 ||
        a == 0x23 ||
        isWithin(a, 0x2c, 0x2f) ||
        a > 0xb6 ||
        (isWithin(a, 0x30, 0xaf) && (a & 3) == 3) // per-op registers from 3x to Ax must not have x3,x7, xB, xF
    );
}

/** Mega Drive GYM bytecode detector. If <= 0, consider invalid.
 * no custom data or end marker to be expected.
 */
function parseMDGYM(p, len) {
    //ref https://plutiedev.com/ym2612-registers
    var tmr;
    if (debug > 0) {
        tmr = new CheckpointTimer();
        tmr.init(300);
    }
    len = len || BCParseToReasonable;
    p = p || 0;
    var max = len == BCParseToEoF ? X.Sz() : Math.min(X.Sz(), p + 0x2000),
        notes = 0,
        v = [0, 0, 0, 0],
        c,
        r,
        x;
    function re(p, t) {
        if (debug > 0) _l2r("gym", p, t);
        return [BCInvalidFormat, p, 0];
    }
    while (p < max)
        switch ((c = X.U8(p++))) {
            case 0:
                break;
            case 1:
            case 2:
                ((r = X.U8(p++)), (x = X.U8(p++)));
                if (!isYM2612Reg(r)) return re(p - 3, c + ": R " + Hex(r));
                if (r == 0x28 && x >> 4) notes += bitCount(x >> 4);
                if ((r & 0xf0) == 0x30) v[0]++; // MUL/DT set
                if ((r & 0xf0) == 0x40 && X.U8(p) > 0) v[1]++; // TL set
                if ((r & 0xf0) == 0x50) v[2]++; // AR/RS set
                if ((r & 0xf0) == 0x60) v[3]++; // DR/AM set
                break;
            case 3:
                p++;
                break;
            default:
                return re(p - 1, "!cmd" + Hex(c));
        }
    if (debug > 0) tmr.next("GYM: end of tested area");
    if (debug > 0) _logIt(outArray([notes, v, p], 16));
    if (!notes || v[0] < 24 || v[1] < 24 || v[2] < 24 || v[3] < 24) return [BCInvalidFormat, p, 0];
    return [notes, p, 0];
}

function MUAP98CmdStr(ch, o, recurse) {
    if (typeof recurse != "number") recurse = 0;
    if (recurse > 2) return "…";
    const C = [
            /*0~2: FM:*/ "FM1: ",
            "FM2: ",
            "FM3: ",
            /*3~5:*/ "SSGA: ",
            "SSGB: ",
            "SSGC: ",
            /*6~8,11~17: FM:*/ "FM4: ",
            "FM5: ",
            "FM6: ",
            /*9,10:*/ "RHY: ",
            "PCM: ",
            "FM7: ",
            /*12~14: either YM3438 or YM2203*/ "FM8: ",
            "FM9: ",
            "FM10: ",
            "FM11: ",
            "FM12: "
        ],
        notes = ["C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B", "C"],
        c = X.U8(o),
        cht = ch == 9 ? "rhy" : ch == 10 ? "pcm" : 3 <= ch && ch <= 5 ? "ssg" : "fm",
        ifop = ["=", ">", "<", "!=" /*the rest always denote FP*/];
    var t;
    if (cht == "fm" && c < 0x40)
        return C[ch] + 'note "' + Hex(c) + '" ' + notes[c % 12] + (1 + Util.divu64(c, 12)) + " ~" + X.U8(o + 1);
    else if (cht == "ssg" && c < 0x10) return C[ch] + 'key-on "' + Hex(c) + '" ' + " ~" + X.U8(o + 1);
    else
        switch (c) {
            case 0xff:
                return C[ch] + "rest";
            case 0xfe:
                return C[ch] + "reset & play";
            case 0xfd:
                return C[ch] + "reset & stop";
            case 0xfc:
                return "-= " + C[ch] + "End. =-";
            case 0xfb:
                return C[ch] + "wait on '";
            case 0xfa:
                return (
                    C[ch] + (ch == 9 || ch == 10 ? "x9 nop" : "3ch 4harm play " + outArray(X.readBytes(o + 1, 8), 16))
                );
            case 0xf9:
                return C[ch] + (ch == 9 || ch == 10 ? "rhy cmd end" : "same freq play");
            case 0xf8:
                return C[ch] + "add freq " + outArray(X.readBytes(o + 1, 3), 16);
            case 0xf7:
                return C[ch] + "loop @" + Hex(o - X.I16(o + 1)) + " x" + Hex(X.U8(o + 3));
            case 0xf6:
                return C[ch] + (cht == "ssg" ? "noise freq " : "pan ") + Hex(X.U8(o + 1));
            case 0xf5:
                return C[ch] + "Timer-A tempo " + Hex(X.U16(o + 1));
            case 0xf4:
                return C[ch] + "set length " + Hex(X.U8(o + 1)) + ", ratio " + Hex(X.U8(o + 2));
            case 0xf3:
                return "wait all channels";
            case 0xf2:
                return (
                    C[ch] +
                    (ch == 9 || ch == 10
                        ? "DSP mode, level, delay" + outArray(X.readBytes(o + 1, 3), 16)
                        : cht == "ssg"
                          ? "set start decay data" + outArray(X.readBytes(o + 1, 3), 16)
                          : "nop")
                );
            case 0xf1:
                return C[ch] + "R" + Hex(X.U8(o + 1)) + " = " + Hex(X.U8(o + 2));
            case 0xf0:
                return C[ch] + (ch == 9 || ch == 10 ? "Rhythm Key On " : "set system detune ") + Hex(X.U8(o + 1));
            case 0xef:
                return C[ch] + (ch == 9 || ch == 10 ? "Rhythm Dump " : "hard LFO speed ") + Hex(X.U8(o + 1));
            case 0xee:
                return (
                    C[ch] +
                    (ch == 9 || ch == 10 ? "Rhythm pan/vol " : "hard LFO AMD,PMD,AMon") +
                    outArray(X.readBytes(o + 1, 2), 16)
                );
            case 0xed:
                return (
                    C[ch] + (ch == 9 || ch == 10 ? "x2 nop" : "3ch 4harm mode " + outArray(X.readBytes(o + 1, 2), 16))
                );
            case 0xec:
                return C[ch] + "key display mask on/off & colour " + Hex(X.U8(o + 1));
            case 0xeb:
                return (
                    C[ch] + (ch == 9 || ch == 10 ? "PCM Tone " : cht == "ssg" ? "mixer mode " : "tone ") + Hex(X.U8(o))
                );
            case 0xea:
                return C[ch] + "@jump " + Hex(o + X.I16(o + 1));
            case 0xe9:
                return (
                    C[ch] +
                    "@call " +
                    Hex(o + X.I16(o + 1)) +
                    ' ("' +
                    MUAP98CmdStr(ch, o + X.I16(o + 1), recurse + 1) +
                    '"...)'
                );
            case 0xe8:
                return C[ch] + "@ret";
            case 0xe7:
                return C[ch] + "Source Line symbolic info " + Hex(X.U16(o + 1));
            case 0xe6:
                return C[ch] + (ch == 9 || ch == 10 || cht == "ssg" ? "x27 nop" : "USR Tone");
            case 0xe5:
                return C[ch] + "Play Stack init";
            case 0xe4:
                return (
                    C[ch] +
                    "@if x" +
                    ((X.U8(o + 1) & 0xf) - 6) +
                    " " +
                    ifop[X.U8(o + 1) >> 4] +
                    " " +
                    X.U8(o + 2) +
                    " jump " +
                    Hex((t = o + 2 + X.I16(o + 3))) +
                    ' ("' +
                    MUAP98CmdStr(ch, t, recurse + 1) +
                    '"...)'
                );
            case 0xe3:
                return (
                    C[ch] +
                    "@if x" +
                    ((X.U8(o + 1) & 0xf) - 6) +
                    " " +
                    ifop[X.U8(o + 1) >> 4] +
                    " " +
                    X.U8(o + 2) +
                    " call " +
                    Hex((t = o + 2 + X.I16(o + 3))) +
                    ' ("' +
                    MUAP98CmdStr(ch, t, recurse + 1) +
                    '")...'
                );
            case 0xe2:
                return C[ch] + "change vol data " + Hex(X.U8(o + 1));
            case 0xe1:
                return C[ch] + "tie";
            case 0xe0:
                return C[ch] + "loopcnt clear";
            case 0xdf:
                return C[ch] + "slur";
            case 0xde:
                return C[ch] + "set ratio " + Hex(X.U8(o + 1));
            case 0xdd:
                return C[ch] + "cmt len " + Hex(X.U8(o + 1));
            case 0xdc:
                return C[ch] + "init Skip_data " + outArray(X.readBytes(o + 1, 3), 16);
            case 0xdb:
                return (
                    C[ch] +
                    "cmt: " +
                    Hex(X.U8(o + 1)) +
                    " " +
                    Hex(X.U8(o + 2)) +
                    ': "' +
                    X.SC(o + 4, X.U8(o + 3), "SJIS") +
                    '"'
                );
            case 0xda:
                return C[ch] + "set X: " + outArray(X.readBytes(o + 1, 3), 16);
            case 0xd9:
                return C[ch] + "set LFO pars. " + outArray(X.readBytes(o + 1, 6), 16);
            case 0xd8:
                return C[ch] + "LFO start(p,a)/stop " + Hex(X.U8(o + 1));
                break; //LFO start(pmd,amd)/stop
            case 0xd7:
                return C[ch] + "vol += " + Hex(X.U8(o + 1));
            case 0xd6:
                return C[ch] + "vol -= " + Hex(X.U8(o + 1));
            case 0xd5:
                return (
                    C[ch] +
                    (ch == 9 || ch == 10 ? "PCM play " : cht == "ssg" ? "Start vol/Attack rate " : "x3 nop ") +
                    X.U16(o)
                );
            case 0xd4:
                return C[ch] + (ch == 9 || ch == 10 ? "PCM addr " + X.U32(o + 1) : "x5 nop");
            case 0xd3:
                var t = (X.U8(o + 1) & 0xf) - 6;
                return (
                    C[ch] +
                    "@if " +
                    (t >= 0 ? "x" + t : "lpcnt") +
                    " " +
                    ifop[X.U8(o + 1) >> 4] +
                    " " +
                    X.U8(o + 2) +
                    " exit " +
                    Hex(o + 5 + X.U16(o + 3))
                );
            case 0xd2:
                return C[ch] + "Play Stack +1";
            case 0xd1:
                return C[ch] + "fade out";
            case 0xd0:
                return C[ch] + "ssg||pcm " + Hex(X.U8(o + 1));
            case 0xcf:
                return C[ch] + "channel change " + Hex(X.U8(o + 1));
            case 0xce:
                return (
                    C[ch] +
                    (ch == 9 || ch == 10
                        ? "set last tone,vol,pan"
                        : cht == "ssg"
                          ? "set last tone,vol"
                          : "?? FM: CEh ??")
                );
            default:
                return C[ch] + "unk. cmd " + Hex(c);
        }
}

/** Packen/ぱっくん Software MUAP98/みゅあっぷ Object bytecode detector. If < 0, consider invalid.
 * The custom data returned is the comment field or "".
 */
function parseMUAP98(p, len, ch) {
    len = len || BCParseToReasonable;
    p = p || 0;
    const p0 = p,
        max =
            len == BCParseToReasonable
                ? Math.min(0x10000, X.Sz(), p + 0x400)
                : len == BCParseToEoF || len == BCParseToEndMarker
                  ? Math.min(0x10000, X.Sz())
                  : p + len;
    var cht = ch == 9 ? "rhy" : ch == 10 ? "pcm" : 3 <= ch && ch <= 5 ? "ssg" : "fm",
        c,
        notes = 0,
        stop = false,
        cmtlen = -1,
        cmt = "",
        /*stack depths:*/ lpd = 1,
        calld = (ifd = mp = ic = 0);
    var visited = [];
    for (i = p0; i < max; i++) visited[i] = false;
    function re(p, t) {
        if (debug > 1) _l2r("muap98", p, "ch" + ch + ": " + t);
        delete visited;
        return [BCInvalidFormat, p, 0];
    }
    while (p0 <= p && p < max && !stop) {
        if (ifd < 0) sus++;
        visited[p] = true;
        if (p > mp) mp = p;
        //_log(Hex(p,4)+': '+MUAP98CmdStr(ch,p));
        c = X.U8(p);
        if (c < 0x40) {
            if (c > 15 && cht == "ssg") return re(p, "!badSSGnote");
            if (!X.U8(p + 1)) ic++; //actually happens...
            notes++;
            p += 2;
        } else if (c < 0xce) return re(p, "!badcmd" + Hex(c));
        else
            switch (c) {
                case 0xff:
                    p++;
                    break; //keyoff and rest for note length
                case 0xfe:
                    lpd = 0;
                    p++;
                    break; //reset & restart
                case 0xfd:
                    p++;
                    stop = true;
                    break; //reset & stop playback
                case 0xfc:
                    stop = true;
                    p++;
                    if (mp < p) mp = p;
                    break; //channel end playback
                case 0xfb:
                    p++;
                    break; /*wait on '*/
                case 0xf9:
                    if (ch != 9) notes++;
                    p++;
                    break; //FM/SSG: same frequency play; RHY/PCM: rhythm cmd end
                case 0xf8:
                    p += 4;
                    break; //add frequency
                case 0xf7:
                    t = p - X.I16(p + 1);
                    if (!isWithin(t, 0x18, max) || Math.abs(t - p) < 2) return re(p, "loop@" + Hex(t));
                    if (!isWithin(t, p0, max)) sus++;
                    p += 4;
                    break; //loop N times
                case 0xf6:
                    p += 2;
                    break; //pan
                case 0xf5:
                    if (!isWithin(X.U16(p + 1), 0x10, 0xfff /*dox: C18 max*/)) return re(p, "!badtempo"); //Timer-A tempo
                    p += 3;
                    break;
                case 0xf4:
                    p += 3;
                    break; //length/ratio change
                case 0xf3:
                    p++;
                    break; //wait all channels: 小節位置を調整する。演奏しているチャネル全てにこのデータが来るまで待機する。
                case 0xf2:
                    p += 4;
                    break; //RHY/PCM: DSP mode, level, delay; FM/SSG: a 4-byte nop
                case 0xf1:
                    p += 3;
                    break; //set reg data
                case 0xf0: //set system detune; RHY/PCM: Rhythm Key on
                    if (ch == 9 || ch == 10) {
                        notes++;
                        if (!X.U8(p + 1)) re(p, "RHY F0: 0");
                    }
                    p += 2;
                    break;
                case 0xdf /*slur*/:
                case 0xd2 /*Play Stack +1*/:
                case 0xd1 /*fade out*/:
                    p++;
                    break;
                case 0xfa:
                    p += 9;
                    break; // 3ch 4harm play; RHY/PCM: a 9-byte nop
                case 0xef:
                    p += 2;
                    break; //hard LFO speed; RHY/PCM: Rhythm Dump
                case 0xee:
                    p += 3;
                    break; //hard LFO AMD, PMD, AMon; RHY/PCM: set Rhythm pan/vol
                case 0xed:
                    p += 2;
                    break; //3ch 4harm mode; RHY/PCM: a 2-byte nop
                case 0xec:
                    p += 2;
                    break; //key display mask on/off & colour
                case 0xeb:
                    p += 2;
                    break; //tone number change
                case 0xea: //@jump, @call
                    t = p + X.I16(p + 1);
                    if (!isWithin(t, 0x18, max) || Math.abs(t - p) < 2) return re(p, "!" + MUAP98CmdStr(ch, p, 1));
                    if (t < p0) ic++;
                    if (visited[t]) stop = true;
                    p = t;
                    break;
                case 0xe9:
                    t = p + X.I16(p + 1);
                    if (!isWithin(t, 0x18, max) || Math.abs(t - p) < 2) return re(p, "!" + MUAP98CmdStr(ch, p, 1));
                    if (t < p0) ic++;
                    calld++;
                    p += 3;
                    break;
                case 0xe8:
                    calld--;
                    if (calld < 0) return re(p, "!RetW/oSub");
                    p++;
                    break; //@ret
                case 0xe7:
                    p += 3;
                    break; //Source Line symbolic information
                case 0xe6:
                    /* if(cht == 'fm') { TODO } */ p += 27;
                    break; //FM: set USR Tone parameter; SSG, RHY, PCM: a 27-byte nop
                case 0xe5:
                    p++;
                    break; //Play Stack init
                case 0xe4:
                case 0xe3: //if @jump, if @call
                    t = p + 2 + X.I16(p + 3);
                    if (!isWithin(t, 0x18, max) || Math.abs(t - p) < 2 || X.U8(p + 1) >> 4 > 3)
                        return re(p, "!" + MUAP98CmdStr(ch, p, 1));
                    if (t < p0) ic++;
                    if (c == 0xe3) calld++;
                    if (c == 0xe4) {
                        if (visited[t]) stop = true;
                        p = t;
                    } else p += 5;
                    break;
                case 0xe2:
                    p += 2;
                    break; //change vol data
                case 0xe1:
                    p++;
                    break; //tie
                case 0xe0:
                    lpd = 0;
                    p++;
                    break; //loop ctr clear
                case 0xde:
                    p += 2;
                    break; //change ratio only
                case 0xdd:
                    cmtlen = X.U8(p + 1);
                    p += 2;
                    break; //doesn't seem to be of any use...
                case 0xdc:
                    p += 4;
                    break; //init Skip_data
                case 0xdb:
                    cmt = cmt.appendS(X.SC(p + 4, X.U8(p + 3), "SJIS"), " / ");
                    p += X.U8(p + 3) + 4;
                    break;
                case 0xda:
                    p += 4;
                    break; //set X Value
                case 0xd9:
                    p += 7;
                    break; //set LFO parameters
                case 0xd8:
                    p += 2;
                    break; //LFO start(pmd,amd)/stop
                case 0xd7:
                case 0xd6:
                    p += 2;
                    break; //increase/decrease vol
                case 0xd5:
                    p += 3;
                    if (ch == 9 || ch == 10) notes++;
                    break; //SSG: Start vol/Attack rate; RHY/PCM: PCM play; FM: a 3-byte nop
                case 0xd4:
                    p += 5;
                    break; //RHY/PCM: set PCM address; FM/SSG: a 5-byte nop
                case 0xd3:
                    p += 5;
                    break; //@if... exit current loop
                case 0xd0:
                    re(p, "ssg/pcm:" + Hex(X.U8(p + 1)));
                    p += 2;
                    break; //SSG||PCM mode
                case 0xcf:
                    ch = X.U8(p + 1);
                    cht = ch == 9 ? "rhy" : ch == 10 ? "pcm" : 3 <= ch && ch <= 5 ? "ssg" : "fm";
                    p += 2;
                    break; //send channel change
                case 0xce:
                    p++;
                    break; //SSG:set last mixer mode, vol, env; RHY/PCM:set last tone/vol/pan (from before sfx)
            }
    }
    return [notes, p, 0, cmt, mp, ic];
}

// -= AdLib/Sound Blaster YM3812/OPL2 related functionality =-

//ref https://web.archive.org/web/20050205055453/http://www.gamedev.net/reference/articles/article446.asp

//The AdLib/OPL2 uses these registers:
function isYM3812Reg(a) {
    return (
        [1, 2, 3, 4, 8, 0xbd].includes(a) ||
        isWithin(a, 0x20, 0x35) ||
        ((isWithin(a, 0x40, 0x55) || isWithin(a, 0x60, 0x75) || isWithin(a, 0x80, 0x95) || isWithin(a, 0xe0, 0xf5)) &&
            [6, 7, 14, 15].indexOf(a & 0x1f) < 0) ||
        isWithin(a, 0xa0, 0xa8) ||
        isWithin(a, 0xb0, 0xb8) ||
        isWithin(a, 0xc0, 0xc8)
    );
}

var __adlibnote = [];
for (var _0 = 0; _0 < 9; _0++) __adlibnote.push([-1, -1, -1]); //channel: key-on, octave, F-num

function YM3812CmdStr(o, recurse) {
    const C = [
            "1.1:",
            "2.1:",
            "3.1:",
            "1.2:",
            "2.2:",
            "3.2:",
            "!6:",
            "!7:",
            "4.1:",
            "5.1:",
            "6.1:",
            "4.2:",
            "5.2:",
            "6.2:",
            "!E:",
            "!F:",
            "7.1:",
            "8.1:",
            "9.1:",
            "7.2:",
            "8.2:",
            "9.2:"
        ],
        wf = ["sine", "/￣\\_", "/￣\\/￣\\", "/|_/|_"],
        //notes = ['C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C'], //TODO? parse the F-number
        c = X.U8(o);
    var t;
    if (c >= 0xe0) return C[c & 0x1f] + "wf " + wf[X.U8(o + 1)];
    else if (c >= 0xc0) return (c & 0xf) + 1 + ":fb/conn" + Hex(X.U8(o + 1));
    else if (c == 0xbd) return "AMdepth/VD/Rhy " + Hex(X.U8(o + 1));
    else if (c >= 0xb0) return (c & 0xf) + 1 + "oct/F_msb/key-on " + Hex(X.U8(o + 1));
    else if (c >= 0xa0) return (c & 0xf) + 1 + "F_lsb " + Hex(X.U8(o + 1));
    else if (c >= 0x80) return C[c & 0x1f] + "S/R " + Hex(X.U8(o + 1));
    else if (c >= 0x60) return C[c & 0x1f] + "A/D " + Hex(X.U8(o + 1));
    else if (c >= 0x40) return C[c & 0x1f] + "level " + Hex(X.U8(o + 1));
    else if (c >= 0x20) return C[c & 0x1f] + "AM/vib/envgen/keyscale/MFmul " + Hex(X.U8(o + 1));
    else if (c == 8) return "CSM/keysplit " + Hex(X.U8(o + 1));
    else if (c == 4) return "tmrctl " + Hex(X.U8(o + 1));
    else if (c == 3) return "tmr2 " + Hex(X.U8(o + 1));
    else if (c == 2) return "tmr1 " + Hex(X.U8(o + 1));
    else if (c == 4) return "test/wfctl " + Hex(X.U8(o + 1));
}

/** AdLib/OPL2 bytecode detector. If <= 0, consider invalid.
 * no custom data or end marker to be expected.
 */
function parseYM3812RegLog(p, len) {
    len = len || BCParseToReasonable;
    p = p || 0;
    var max = len == BCParseToEoF ? X.Sz() - 2 : Math.min(X.Sz() - 2, p + 0x2000),
        notes = 0,
        v = [0, 0, 0, 0],
        c,
        r,
        x,
        tmr;
    if (debug > 0) {
        tmr = new CheckpointTimer();
        tmr.init(300);
    }
    function re(p, t) {
        if (debug > 1) _l2r("adlib", p, t);
        return [BCInvalidFormat, p, 0];
    }
    while (!X.U8(p) && p < 0x2000) p++; //skip zeroes if any
    if (!X.U8(p)) return [BCInvalidFormat, p, 0]; //sanity, heuristics, just reasonable they'd cut off the meaningless zeroes
    while (p < max) {
        r = X.U8(p++);
        x = X.U8(p++);
        if (!isYM3812Reg(r)) return re(p - 2, "R " + Hex(r) + " : " + Hex(x));
        if (r == 0x28 && x >> 4) notes += bitCount(x >> 4);
        if ((r & 0xf0) == 0x30) v[0]++; // MUL/DT set
        if ((r & 0xf0) == 0x40 && X.U8(p) > 0) v[1]++; // TL set
        if ((r & 0xf0) == 0x50) v[2]++; // AR/RS set
        if ((r & 0xf0) == 0x60) v[3]++; // DR/AM set
    }
    if (debug > 0) tmr.next("OPM chiptune: end of parsed data");
    if (debug > 0) _logIt(outArray([notes, v, p], 16));
    if (!notes || v[0] < 24 || v[1] < 24 || v[2] < 24 || v[3] < 24) return [BCInvalidFormat, p, 0];
    return [notes, p, 0];
}

/* beautify ignore:end */
